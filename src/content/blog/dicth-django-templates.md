---
publish: false

title: 'Generate Django pages with Astro: Ditching Django Templates'
description: ''
image: ''

published: 'Jul 25 2023'
created: 'Jul 25 2023'

tags: ['django', 'astro', 'ssg']
---

> This post/setup is a work in progress as I'm still experimenting. I'll update as I learn more.

Elevate Your Django Development with Astro: The Ultimate Guide to Moving Beyond Django Templates
Introduction

Django is a leading backend framework that many developers, including myself, lean on for its robust and comprehensive features. Yet, there's a facet of Django that some find limiting - its templating system. Though not terrible, it's fair to say that Django templates are not the epitome of flexibility, nor are they particularly intuitive or extensible. To address these challenges, I decided to transition from Django templates to Astro. This article outlines the early findings from my exploration and experimentation.
The Power of Astro

Astro is a highly adaptable static site generator (SSG) that operates by creating .html files, which Django views can then consume. For context, consider the following directory structure. While some developers may prefer nesting the Astro project within the Django project, I find it more logical to keep them separate:

bash

├── astro-ssg
│ ├── ...
│ ├── src
│ ├── astro.config.mjs
│ ├── package.json
│ ├── ...
├── django_backend
│ ├── ...
│ ├── config
│ ├── media
│ ├── static
│ ├── templates
│ ├── ...

Astro Configuration for Django Integration

The first step involves configuring Astro to generate .html files in the Django templates directory. By adding the following configuration to astro.config.mjs, you can achieve this:

js

export default defineConfig({
// ...
output: 'static',
trailingSlash: 'always',
scopedStyleStrategy: 'class',
publicDir: '../django_backend/media/',
compressHTML: process.env.NODE_ENV === 'production',
buildOptions: {
format: 'file',
inlineStylesheets: 'always',
assets: 'static',
},
// ...
});

Configuring Django to Serve Astro-Generated Static Files

Next, Django needs to be set up to serve the static files generated by Astro. This can be done by adding the subsequent lines to the django_backend/config/settings.py file:

py

TEMPLATES_DIR = BASE_DIR / 'templates'

SSG_DIR = BASE_DIR.parent / 'astro-ssg'

# ...

STATIC_URL = 'static/'
STATIC_ROOT = BASE_DIR / 'static'
STATICFILES_DIRS = [
TEMPLATES_DIR / 'ssg/static',
]

# ...

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# ...

Guiding Django to Use Astro-Generated .html Files as Templates

Further, Django needs to recognize the Astro-generated .html files as templates. Achieve this by integrating the subsequent code into django_backend/config/settings.py:

py

TEMPLATES = [
{
'BACKEND': 'django.template.backends.django.DjangoTemplates',
'DIRS': [TEMPLATES_DIR],
'APP_DIRS': True,
'OPTIONS': {
'context_processors': [

# ...

],
},
},
]

Watching for Changes in Astro Projects

As of now, Astro does not offer a watch mode, meaning you'll need to run astro build after every change made to the Astro project for the backend to acknowledge them. A convenient workaround to this is automating the process with chokidar, similar to how remix does it.

The following can be added to package.json:

json

{
"scripts": {
"watch": "node watch.js"
}
}

Then add a watch.js to the root of the Astro project:

````js

import { spawn } from 'child_process';
import chokidar from 'chokidar';

const watcher = chokidar.watch('src/\*_/_');

watcher.on('ready', () => {
watcher.on('change', () => {
spawn('yarn', ['build'], { stdio: 'inherit' });
});
});```

You can then run yarn run watch to initialize the watcher. Henceforth, every time changes are made to the Astro project, Astro will rebuild the project, and Django will register the changes.
Harnessing the Astro-Django Setup

With the configuration mentioned above, Django's context can still be utilized in conjunction with templates. For example, .astro files can be modified like this:

```tsx

<a href="{{ request.path }}?tab=today">Today</a>
<a href="{{ request.path }}?tab=tomorrow">Tomorrow</a>
````

In the above example, {{ request.path }} will be replaced with the actual path when the page renders.
Conclusion

By transitioning to Astro, you can enhance the flexibility and extensibility of your Django project while maintaining seamless integration. Although it might seem complex at first, the effort is worthwhile. Not only does it significantly improve your Django development experience, but it also paves the way for superior project outcomes.
